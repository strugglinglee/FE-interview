(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{418:function(t,s,a){"use strict";a.r(s);var e=a(56),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"路由篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由篇"}},[t._v("#")]),t._v(" 路由篇")]),t._v(" "),a("h2",{attrs:{id:"vue路由hash模式和history模式实现原理分别是什么-他们的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue路由hash模式和history模式实现原理分别是什么-他们的区别是什么"}},[t._v("#")]),t._v(" vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？")]),t._v(" "),a("ul",[a("li",[t._v("hash 模式：\n"),a("ul",[a("li",[t._v("#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面")]),t._v(" "),a("li",[t._v("通过监听 "),a("strong",[t._v("hashchange")]),t._v(" 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。")])])]),t._v(" "),a("li",[t._v("history 模式：\n"),a("ul",[a("li",[t._v("history 模式的实现，主要是 HTML5 标准发布的两个 API，"),a("strong",[t._v("pushState")]),t._v(" 和 "),a("strong",[t._v("replaceState")]),t._v("，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作")])])]),t._v(" "),a("li",[t._v("区别\n"),a("ul",[a("li",[t._v("url 展示上，hash 模式有“#”，history 模式没有")]),t._v(" "),a("li",[t._v("刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由")]),t._v(" "),a("li",[t._v("兼容性，hash 可以支持低版本浏览器和 IE。")])])])]),t._v(" "),a("h2",{attrs:{id:"路由懒加载是什么意思-如何实现路由懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载是什么意思-如何实现路由懒加载"}},[t._v("#")]),t._v(" 路由懒加载是什么意思？如何实现路由懒加载？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("路由懒加载的含义：把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件")])]),t._v(" "),a("li",[a("p",[t._v("实现：结合 Vue 的异步组件和 Webpack 的代码分割功能")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[a("p",[t._v("可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Foo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" Promise"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 组件定义对象 */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[a("p",[t._v("在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./Foo.vue'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回 Promise")]),t._v("\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("```js\nconst Foo = () => import('./Foo.vue')\nconst router = new VueRouter({ routes: [ { path: '/foo', component: Foo } ]})\n```\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("使用命名 chunk，和webpack中的魔法注释就可以把某个路由下的所有组件都打包在同个异步块 (chunk) 中")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Foo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* webpackChunkName: "group-foo" */')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./Foo.vue'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h2",{attrs:{id:"vue-router-导航守卫有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-导航守卫有哪些"}},[t._v("#")]),t._v(" Vue-router 导航守卫有哪些")]),t._v(" "),a("ul",[a("li",[t._v("全局前置/钩子：beforeEach、beforeResolve、afterEach")]),t._v(" "),a("li",[t._v("路由独享的守卫：beforeEnter")]),t._v(" "),a("li",[t._v("组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave")])])])}),[],!1,null,null,null);s.default=r.exports}}]);