(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{422:function(e,v,t){"use strict";t.r(v);var _=t(56),r=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"基础篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[e._v("#")]),e._v(" 基础篇")]),e._v(" "),t("h2",{attrs:{id:"说说你对mvvm的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说你对mvvm的理解"}},[e._v("#")]),e._v(" 说说你对MVVM的理解")]),e._v(" "),t("ul",[t("li",[e._v("Model-View-ViewModel的缩写，Model代表数据模型，View代表UI组件,ViewModel将Model和View关联起来")]),e._v(" "),t("li",[e._v("数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知"),t("strong",[e._v("viewModel")]),e._v("层更新数据")])]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://juejin.im/post/5e898a3be51d45470125665f",target:"_blank",rel:"noopener noreferrer"}},[e._v("了解mvc/mvp/mvvm的区别"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"vue2-x响应式数据-双向绑定原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x响应式数据-双向绑定原理"}},[e._v("#")]),e._v(" Vue2.x响应式数据/双向绑定原理")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Vue 数据双向绑定主要是指："),t("strong",[e._v("数据变化更新视图，视图变化更新数据")]),e._v("。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何"),t("strong",[e._v("根据Data变化更新View")]),e._v("。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("简述")]),e._v("：")]),e._v(" "),t("ul",[t("li",[e._v("当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。")]),e._v(" "),t("li",[e._v("这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。")]),e._v(" "),t("li",[e._v("每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")])])]),e._v(" "),t("li",[t("p",[e._v("深入理解：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("监听器 Observer")]),e._v("：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。")]),e._v(" "),t("li",[t("strong",[e._v("解析器 Compile")]),e._v("：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。")]),e._v(" "),t("li",[t("strong",[e._v("订阅者 Watcher")]),e._v("：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式")]),e._v(" "),t("li",[t("strong",[e._v("订阅器 Dep")]),e._v("：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。")])])])]),e._v(" "),t("h2",{attrs:{id:"computed-和-watch-的区别和运用的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别和运用的场景"}},[e._v("#")]),e._v(" computed 和 watch 的区别和运用的场景？")]),e._v(" "),t("ul",[t("li",[e._v("computed：是计算属性，依赖其它属性值，并且 computed 的值有"),t("strong",[e._v("缓存")]),e._v("，只有它"),t("strong",[e._v("依赖的属性值")]),e._v("发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；")]),e._v(" "),t("li",[e._v("watch：没有缓存性，更多的是「"),t("strong",[e._v("观察")]),e._v("」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听")]),e._v(" "),t("li",[t("strong",[e._v("运用场景")]),e._v("：\n"),t("ul",[t("li",[e._v("当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；")]),e._v(" "),t("li",[e._v("当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])])])]),e._v(" "),t("h2",{attrs:{id:"vue2-x组件通信有哪些方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x组件通信有哪些方式"}},[e._v("#")]),e._v(" Vue2.x组件通信有哪些方式？")]),e._v(" "),t("ul",[t("li",[e._v("父子组件通信\n"),t("ul",[t("li",[e._v("事件机制(**父->子props,子->父 "),t("code",[e._v("$on、$emit")]),e._v(")")]),e._v(" "),t("li",[e._v("获取父子组件实例 "),t("code",[e._v("$parent、$children")])]),e._v(" "),t("li",[e._v("Ref 获取实例的方式调用组件的属性或者方法")]),e._v(" "),t("li",[e._v("Provide、inject (不推荐使用，组件库时很常用)")])])]),e._v(" "),t("li",[e._v("兄弟组件通信\n"),t("ul",[t("li",[t("strong",[e._v("eventBus")]),e._v(" 这种方法通过"),t("strong",[e._v("一个空的 Vue实例作为中央事件总线（事件中心")]),e._v("），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件\n"),t("blockquote",[t("p",[e._v("Vue.prototype."),t("code",[e._v("$bus")]),e._v(" = new Vue")])])]),e._v(" "),t("li",[t("strong",[e._v("Vuex")])])])]),e._v(" "),t("li",[e._v("跨级组件通信\n"),t("ul",[t("li",[e._v("Vuex")]),e._v(" "),t("li",[t("code",[e._v("$attrs、$listeners")])]),e._v(" "),t("li",[e._v("Provide、inject")])])])]),e._v(" "),t("h2",{attrs:{id:"说一下v-if和v-show的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下v-if和v-show的区别"}},[e._v("#")]),e._v(" 说一下v-if和v-show的区别")]),e._v(" "),t("ul",[t("li",[e._v("当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。")]),e._v(" "),t("li",[e._v("v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；")]),e._v(" "),t("li",[e._v("v-show 则适用于需要非常频繁切换条件的场景。")])]),e._v(" "),t("h2",{attrs:{id:"为什么-v-for-和-v-if-不建议用在一起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-v-for-和-v-if-不建议用在一起"}},[e._v("#")]),e._v(" 为什么 v-for 和 v-if 不建议用在一起")]),e._v(" "),t("ul",[t("li",[e._v("当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费")]),e._v(" "),t("li",[e._v("这种场景建议使用 computed，先对数据进行过滤")])]),e._v(" "),t("h2",{attrs:{id:"组件中的data为什么是一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件中的data为什么是一个函数"}},[e._v("#")]),e._v(" 组件中的data为什么是一个函数？")]),e._v(" "),t("ul",[t("li",[e._v("一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。")]),e._v(" "),t("li",[e._v("如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。")])]),e._v(" "),t("h2",{attrs:{id:"子组件为什么不可以修改父组件传递的prop-怎么理解vue的单向数据流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子组件为什么不可以修改父组件传递的prop-怎么理解vue的单向数据流"}},[e._v("#")]),e._v(" 子组件为什么不可以修改父组件传递的Prop？/怎么理解vue的单向数据流？")]),e._v(" "),t("ul",[t("li",[e._v("Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。")]),e._v(" "),t("li",[e._v("这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。")]),e._v(" "),t("li",[e._v("如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。")])]),e._v(" "),t("h2",{attrs:{id:"v-model是如何实现双向绑定的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-model是如何实现双向绑定的"}},[e._v("#")]),e._v(" v-model是如何实现双向绑定的？")]),e._v(" "),t("ul",[t("li",[e._v("v-model是用来在表单控件或者组件上创建双向绑定的")]),e._v(" "),t("li",[e._v("他的本质是v-bind和v-on的语法糖")]),e._v(" "),t("li",[e._v("在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件")])]),e._v(" "),t("h2",{attrs:{id:"nexttick的实现原理是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的实现原理是什么"}},[e._v("#")]),e._v(" nextTick的实现原理是什么？")]),e._v(" "),t("ul",[t("li",[e._v("在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。")]),e._v(" "),t("li",[e._v("nextTick主要使用了"),t("strong",[e._v("宏任务")]),e._v("和"),t("strong",[e._v("微任务")]),e._v("。")]),e._v(" "),t("li",[e._v("根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。")])]),e._v(" "),t("h2",{attrs:{id:"vue不能检测数组的哪些变动-vue-怎么用-vm-set-解决对象新增属性不能响应的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue不能检测数组的哪些变动-vue-怎么用-vm-set-解决对象新增属性不能响应的问题"}},[e._v("#")]),e._v(" Vue不能检测数组的哪些变动？Vue 怎么用 "),t("code",[e._v("vm.$set()")]),e._v(" 解决对象新增属性不能响应的问题 ？")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Vue 不能检测以下数组的变动：")]),e._v(" "),t("ul",[t("li",[e._v("当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue")]),e._v(" "),t("li",[e._v("当你修改数组的长度时，例如：vm.items.length = newLength")]),e._v(" "),t("li",[e._v("解决办法：\n"),t("ul",[t("li",[t("p",[e._v("第一类问题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  ```\n  // 法一：Vue.set\n  Vue.set(vm.items, indexOfItem, newValue)\n  // 法二：Array.prototype.splice\n  vm.items.splice(indexOfItem, 1, newValue)\n  ```\n")])])])]),e._v(" "),t("li",[t("p",[e._v("第二类问题，可使用 splice：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  ```\n  vm.items.splice(newLength)\n  ```\n")])])])])])])])]),e._v(" "),t("li",[t("p",[e._v("vm."),t("code",[e._v("$set")]),e._v(" 的实现原理是：")]),e._v(" "),t("ul",[t("li",[e._v("如果目标是数组，直接使用数组的 splice 方法触发相应式；")]),e._v(" "),t("li",[e._v("如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）")])])])]),e._v(" "),t("h2",{attrs:{id:"vue事件绑定原理是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue事件绑定原理是什么"}},[e._v("#")]),e._v(" Vue事件绑定原理是什么？")]),e._v(" "),t("ul",[t("li",[e._v("原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的"),t("code",[e._v("$on")]),e._v("实现的。")])]),e._v(" "),t("h2",{attrs:{id:"说一下虚拟dom以及key属性的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下虚拟dom以及key属性的作用"}},[e._v("#")]),e._v(" 说一下虚拟Dom以及key属性的作用")]),e._v(" "),t("ul",[t("li",[e._v("由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。")]),e._v(" "),t("li",[e._v("Virtual DOM本质就是用一个"),t("strong",[e._v("原生的JS对象去描述一个DOM节点")]),e._v("。是对真实DOM的一层抽象。(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)")]),e._v(" "),t("li",[e._v("虚拟 DOM 的实现原理主要包括以下 3 部分：\n"),t("ul",[t("li",[e._v("用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；")]),e._v(" "),t("li",[e._v("diff 算法 — 比较两棵虚拟 DOM 树的差异；")]),e._v(" "),t("li",[e._v("pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。")])])]),e._v(" "),t("li",[e._v("key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速\n"),t("ul",[t("li",[e._v("更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。")]),e._v(" "),t("li",[e._v("更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快")])])])]),e._v(" "),t("h2",{attrs:{id:"为什么不建议用index作为key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不建议用index作为key"}},[e._v("#")]),e._v(" 为什么不建议用index作为key?")]),e._v(" "),t("ul",[t("li",[e._v("不建议 用index 作为 key，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作")])])])}),[],!1,null,null,null);v.default=r.exports}}]);