(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{427:function(t,e,a){"use strict";a.r(e);var o=a(56),i=Object(o.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vuex篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex篇"}},[t._v("#")]),t._v(" VUEX篇")]),t._v(" "),a("h2",{attrs:{id:"vuex-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-是什么"}},[t._v("#")]),t._v(" Vuex 是什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("运用到了js设计模式中的单例模式，单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。")])]),t._v(" "),a("ul",[a("li",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n"),a("ul",[a("li",[t._v("Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。")]),t._v(" "),a("li",[t._v("改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档")])]),t._v(" "),a("ul",[a("li",[t._v("主要包括以下几个模块：\n"),a("ul",[a("li",[t._v("State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),t._v(" "),a("li",[t._v("Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。")]),t._v(" "),a("li",[t._v("Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。")]),t._v(" "),a("li",[t._v("Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。")]),t._v(" "),a("li",[t._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。")])])])]),t._v(" "),a("h2",{attrs:{id:"什么情况下使用-vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下使用-vuex"}},[t._v("#")]),t._v(" 什么情况下使用 Vuex？")]),t._v(" "),a("ul",[a("li",[t._v("如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可")]),t._v(" "),a("li",[t._v("需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态")])]),t._v(" "),a("h2",{attrs:{id:"vuex和单纯的全局对象有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex和单纯的全局对象有什么区别"}},[t._v("#")]),t._v(" Vuex和单纯的全局对象有什么区别？")]),t._v(" "),a("ul",[a("li",[t._v("Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。")]),t._v(" "),a("li",[t._v("不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。")])]),t._v(" "),a("h2",{attrs:{id:"为什么-vuex-的-mutation-中不能做异步操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么-vuex-的-mutation-中不能做异步操作"}},[t._v("#")]),t._v(" 为什么 Vuex 的 mutation 中不能做异步操作？")]),t._v(" "),a("ul",[a("li",[t._v("Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。")]),t._v(" "),a("li",[t._v("每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。")])]),t._v(" "),a("h2",{attrs:{id:"新增-vuex的action有返回值吗-返回的是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新增-vuex的action有返回值吗-返回的是什么"}},[t._v("#")]),t._v(" 新增：vuex的action有返回值吗？返回的是什么？")]),t._v(" "),a("ul",[a("li",[t._v("store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise")]),t._v(" "),a("li",[t._v("Action 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程，可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程")])]),t._v(" "),a("blockquote",[a("p",[t._v("一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。")])]),t._v(" "),a("h2",{attrs:{id:"新增-为什么不直接分发mutation-而要通过分发action之后提交-mutation变更状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新增-为什么不直接分发mutation-而要通过分发action之后提交-mutation变更状态"}},[t._v("#")]),t._v(" 新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态")]),t._v(" "),a("ul",[a("li",[t._v("mutation 必须同步执行，我们可以在 action 内部执行异步操作")]),t._v(" "),a("li",[t._v("可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）")])])])}),[],!1,null,null,null);e.default=i.exports}}]);